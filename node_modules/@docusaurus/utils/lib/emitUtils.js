"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.readOutputHTMLFile = exports.genChunkName = exports.generate = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const crypto_1 = require("crypto");
const hashUtils_1 = require("./hashUtils");
const jsUtils_1 = require("./jsUtils");
const fileHash = new Map();
async function generate(generatedFilesDir, file, content, skipCache = process.env.NODE_ENV === 'production') {
    const filepath = path_1.default.join(generatedFilesDir, file);
    if (skipCache) {
        await fs_extra_1.default.ensureDir(path_1.default.dirname(filepath));
        await fs_extra_1.default.writeFile(filepath, content);
        return;
    }
    let lastHash = fileHash.get(filepath);
    // If file already exists but its not in runtime cache yet,
    // we try to calculate the content hash and then compare
    // This is to avoid unnecessary overwriting and we can reuse old file.
    if (!lastHash && (await fs_extra_1.default.pathExists(filepath))) {
        const lastContent = await fs_extra_1.default.readFile(filepath, 'utf8');
        lastHash = (0, crypto_1.createHash)('md5').update(lastContent).digest('hex');
        fileHash.set(filepath, lastHash);
    }
    const currentHash = (0, crypto_1.createHash)('md5').update(content).digest('hex');
    if (lastHash !== currentHash) {
        await fs_extra_1.default.ensureDir(path_1.default.dirname(filepath));
        await fs_extra_1.default.writeFile(filepath, content);
        fileHash.set(filepath, currentHash);
    }
}
exports.generate = generate;
const chunkNameCache = new Map();
/**
 * Generate unique chunk name given a module path.
 */
function genChunkName(modulePath, prefix, preferredName, shortId = process.env.NODE_ENV === 'production') {
    let chunkName = chunkNameCache.get(modulePath);
    if (!chunkName) {
        if (shortId) {
            chunkName = (0, hashUtils_1.simpleHash)(modulePath, 8);
        }
        else {
            let str = modulePath;
            if (preferredName) {
                const shortHash = (0, hashUtils_1.simpleHash)(modulePath, 3);
                str = `${preferredName}${shortHash}`;
            }
            const name = str === '/' ? 'index' : (0, hashUtils_1.docuHash)(str);
            chunkName = prefix ? `${prefix}---${name}` : name;
        }
        chunkNameCache.set(modulePath, chunkName);
    }
    return chunkName;
}
exports.genChunkName = genChunkName;
/**
 * @param permalink The URL that the HTML file corresponds to, without base URL
 * @param outDir Full path to the output directory
 * @param trailingSlash The site config option. If provided, only one path will
 * be read.
 * @returns This returns a buffer, which you have to decode string yourself if
 * needed. (Not always necessary since the output isn't for human consumption
 * anyways, and most HTML manipulation libs accept buffers)
 */
async function readOutputHTMLFile(permalink, outDir, trailingSlash) {
    const withTrailingSlashPath = path_1.default.join(outDir, permalink, 'index.html');
    const withoutTrailingSlashPath = path_1.default.join(outDir, `${permalink.replace(/\/$/, '')}.html`);
    if (trailingSlash) {
        return fs_extra_1.default.readFile(withTrailingSlashPath);
    }
    else if (trailingSlash === false) {
        return fs_extra_1.default.readFile(withoutTrailingSlashPath);
    }
    const HTMLPath = await (0, jsUtils_1.findAsyncSequential)([withTrailingSlashPath, withoutTrailingSlashPath], fs_extra_1.default.pathExists);
    if (!HTMLPath) {
        throw new Error(`Expected output HTML file to be found at ${withTrailingSlashPath}`);
    }
    return fs_extra_1.default.readFile(HTMLPath);
}
exports.readOutputHTMLFile = readOutputHTMLFile;
//# sourceMappingURL=emitUtils.js.map